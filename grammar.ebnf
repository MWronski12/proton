(* Program structure *)

Program
    = { Declaration | Definition };


(* Lexical conventions *)

identifier 
    = ? RETURNED BY LEXER ?;
typeIdentifier
    = identifier;
primitiveType
    = "int"
    | "float"
    | "char"
    | "bool"
    | "string";


(* LITERALS *)

literal 
    = integerLiteral 
    | floatLiteral 
    | stringLiteral 
    | boolLiteral 
    | variantLiteral 
    | objectLiteral;

integerLiteral
    = ? RETURNED BY LEXER ?;
floatLiteral
    = ? RETURNED BY LEXER ?;
charLiteral
    = ? RETURNED BY LEXER ?;
boolLiteral 
    = ? RETURNED BY LEXER ?;
stringLiterals
    = ? RETURNED BY LEXER ?;

variantLiteral 
    = typeIdentifier, "{", expression, [ "," ], "}";

objectLiteral
    = typeIdentifier, "{" , memberValues, [ "," ], "}";
memberValues 
    = memberValue, { ",", memberValue };
memberValue 
    = [ identifier, ":" ], expression;


(* EXPRESSIONS *)

expression 
    = logicOrExpr;

logicOrExpr 
    = logicAndExpr, { logicOrOp, logicAndExpr };
logicAndExpr 
    = equalityExpr, { equalityOp, equalityExpr };
equalityExpr
    = relationalExpr, { equalityOp, relationalExpr };
relationalExpr 
    = additiveExpr, { relationalOp, additiveExpr };
additiveExpr 
    = multiplicativeExpr, { additiveOp, multiplicativeExpr };
multiplicativeExpr 
    = unaryOpExpr, { multiplicativeOp, unaryOpExpr };
unaryOpExpr
    = [ unaryOp ], functionalExpr;
functionalExpr
    = primaryExpr, { functionalOp };

primaryExpr
    = parenExpr
    | castExpr
    | literal
    | identifier;

parenExpr 
    = "(", expression, ")";
castExpr
    = primitiveType, "(", expression, ")";


(* OPERATORS *)

logicOrOp                   (* prio 0 l-r *)
    = "||";

logicAndOp                  (* prio 1 l-r *)
    = "&&";

equalityOp                  (* prio 2 l-r *)
    = "==" 
    | "!=";

relationalOp                (* prio 3 l-r *)
    = "<" 
    | ">" 
    | "<=" 
    | ">=";

additiveOp                  (* prio 4 l-r *)
    = "+" 
    | "-";

multiplicativeOp            (* prio 5 l-r *)
    = "*" 
    | "/" 
    | "%";

unaryOp                     (* prio 6 r-l *)
    = "!"
    | "-";

functionalOp                (* prio 7 l-r *)
    = fnCallOp 
    | memberAccessOp 
    | variantAccessOp;

fnCallOp
    = "(", [ expression, { ",", expression } ], ")"; 
memberAccessOp 
    = ".", identifier;
variantAccessOp
    = "as", typeIdentifier;


(* DECLARATIONS *)

Declaration
    = VarDecl;
VarDecl
    = identifier, ":", typeIdentifier, ";";


(* DEFINITIONS *)

Definition
    = VarDef
    | StructDef
    | VariantDef
    | FnDef;

VarDef
    = [ "const" ], identifier, ":", typeIdentifier, "=", expression, ";";

StructDef
    = "struct", identifier, "{", [ structMembers ] "}", ";";
structMembers
    = typeIdentifier, { typeIdentifier };

VariantDef
    = "variant", identifier, "{", variantTypes, "}", ";";
variantTypes 
    = typeIdentifier, { typeIdentifier };

FnDef
    = "fn", identifier, "(", [ fnParameters ], ")", returnTypeAnnotation, Block;
fnParameters
    = fnParameter, { ",", fnParameter };
fnParameter
    = [ "const" ], identifier, ":", typeIdentifier;
fnReturnType
    = "->", typeIdentifier;



(* STATEMENTS *)

Statement
    = VarDecl
    | VarDef
    | StdinExtraction
    | StdoutInsertion
    | AssignmentStatement
    | ExpressionStatement
    | VariantMatchStatement
    | IfStatement
    | ForStatement
    | WhileStatement
    | ContinueStatement
    | BreakStatement
    | ReturnStatement
    | Block;

StdinExtraction
    = ">>", expression, ";";
StdoutInsertion
    = "<<", expression, { "<<", expression }, ";";

AssignmentStatement
    = expression, "=", expression, ";";

ExpressionStatement
    = expression, ";";

VariantMatchStatement
    = "match", expression, "{", { variantCase }, "}";
variantCase
    = "case", typeIdentifier, "->", Block;

IfStatement
    = "if", { elifClause }, [ elseClause ];
elifClause
    = "elif", expression, Block;
elseClause
    = "else", Block;

WhileStatement
    = "while", expression, Block;

ForStatement
    = "for", identifier, "in", range, Block;
range
    = expression, "until", expression;

ReturnStatement
    = "return", [ expression ], ";";

BreakStatement
    = "break", ";";
ContinueStatement
    = "continue", ";";

Block
    = "{", { Statement }, "}";
