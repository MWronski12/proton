(* Program structure *)

Program
    = { TypeDef | FnDef }, MainFunction;
    
MainFunction
    = "fn", "main()", "->", "int", Block;


(* Lexical conventions *)

identifier 
    = ? RETURNED BY LEXER ?;
typeIdentifier
    = identifier;
primitiveType
    = "int"
    | "float"
    | "char"
    | "bool"
    | "string";


(* LITERALS *)

literal 
    = integerLiteral 
    | floatLiteral 
    | stringLiteral 
    | boolLiteral 
    | variantLiteral 
    | objectLiteral;

integerLiteral 
    = ? RETURNED BY LEXER ?;
floatLiteral 
    = ? RETURNED BY LEXER ?;
charLiteral 
    = ? RETURNED BY LEXER ?;
boolLiteral 
    = ? RETURNED BY LEXER ?;
stringLiterals
    = ? RETURNED BY LEXER ?;

variantLiteral 
    = typeIdentifier, "{", expression, [ "," ], "}";

objectLiteral
    = typeIdentifier, "{" , fieldValues, [ "," ], "}";
fieldValues 
    = fieldValue, { ",", fieldValue };
fieldValue 
    = [ identifier, ":" ], expression;


(* EXPRESSIONS *)

expression 
    = logicOrExpr;

logicOrExpr 
    = logicAndExpr, { logicOrOp, logicAndExpr };
logicAndExpr 
    = equalityExpr, { equalityOp, equalityExpr };
equalityExpr
    = relationalExpr, { equalityOp, relationalExpr };
relationalExpr 
    = additiveExpr, { relationalOp, additiveExpr };
additiveExpr 
    = multiplicativeExpr, { additiveOp, multiplicativeExpr };
multiplicativeExpr 
    = unaryOpExpr, { multiplicativeOp, unaryOpExpr };
unaryOpExpr
    = [ unaryOp ], functionalExpr;
functionalExpr
    = primaryExpr, { functionalOp };

primaryExpr
    = parenExpr
    | castExpr
    | literal
    | identifier;

parenExpr 
    = "(", expression, ")";
castExpr
    = primitiveType, "(", expression, ")";


(* OPERATORS *)

logicOrOp                   (* prio 0 l-r *)
    = "||";

logicAndOp                  (* prio 1 l-r *)
    = "&&";

equalityOp                  (* prio 2 l-r *)
    = "==" 
    | "!=";

relationalOp                (* prio 3 l-r *)
    = "<" 
    | ">" 
    | "<=" 
    | ">=";

additiveOp                  (* prio 4 l-r *)
    = "+" 
    | "-";

multiplicativeOp            (* prio 5 l-r *)
    = "*" 
    | "/" 
    | "%";

unaryOp                     (* prio 6 r-l *)
    = "!"
    | "-";

functionalOp                (* prio 7 l-r *)
    = fnCallOp 
    | memberAccessOp 
    | variantAccessOp;

fnCallOp
    = "(", [ expression, { ",", expression } ], ")"; 
memberAccessOp 
    = ".", identifier;
variantAccessOp
    = "as", typeIdentifier;


(* DECLARATIONS *)

VarDecl 
    = identifier, ":", typeIdentifier, ";";


(* DEFINITIONS *)

VarDef
    = [ "const" ], identifier, ":", typeIdentifier, "=", expression, ";";

TypeDef
    = StructDef | VariantDef;
StructDef
    = "struct", identifier, "{", { VarDecl }, "}", ";";
VariantDef
    = "variant", identifier, "{", { typeIdentifier }, "}", ";";

FnDef
    = "fn", identifier, "(", [ parameters ], ")", returnTypeAnnotation, Block;
parameters
    = parameter, { ",", parameter };
parameter
    = [ "const" ], identifier, ":", typeIdentifier;
returnTypeAnnotation
    = "->", ( typeIdentifier | "void" );



(* STATEMENTS *)

Statement 
    = VarDecl
    | VarDef
    | StdinExtraction
    | StdoutInsertion
    | AssignmentStatement
    | ExpressionStatement
    | VariantMatchStatement
    | IfStatement
    | ForStatement
    | WhileStatement
    | ContinueStatement
    | BreakStatement
    | ReturnStatement
    | Block;

StdinExtraction
    = ">>", expression, ";";
StdoutInsertion
    = "<<", expression, { "<<", expression }, ";";

AssignmentStatement
    = expression, "=", expression, ";";

ExpressionStatement
    = expression, ";";

VariantMatchStatement
    = "match", expression, "{", { variantCase }, "}";
variantCase
    = "case", typeIdentifier, "->", Block;

IfStatement
    = "if", { elifClause }, [ elseClause ];
elifClause
    = "elif", expression, Block;
elseClause
    = "else", Block;

WhileStatement
    = "while", expression, Block;

ForStatement
    = "for", identifier, "in", range, Block;
range
    = expression, "until", expression;

ReturnStatement
    = "return", [ expression ], ";";

BreakStatement
    = "break", ";";
ContinueStatement
    = "continue", ";";

Block
    = "{", { Statement }, "}";
