(* Program structure *)

Program
    = { Definition };


(* Lexical conventions *)

identifier                              (* RETURNED BY LEXER *) 
    = [_a-zA-Z][_a-zA-Z0-9]*;           
typeIdentifier
    = identifier;
primitiveType                           (* RETURNED BY LEXER *)
    = "int"
    | "float"
    | "char"
    | "bool"
    | "string";


(* LITERALS *)

literal
    = primitiveLiteral
    | objectLiteral;

primitiveLiteral                        (* RETURNED BY LEXER *)
    = integerLiteral 
    | floatLiteral
    | charLiteral
    | boolLiteral 
    | stringLiteral;

objectLiteral
    = "{", [ memberValues ], "}";
memberValues
    =  memberValue, {",", memberValue };
memberValue
    = identifier, ":", expression;


(* EXPRESSIONS *)

expression 
    = logicOrExpr;

logicOrExpr 
    = logicAndExpr, { logicOrOp, logicAndExpr };
logicAndExpr 
    = equalityExpr, { logicAndOp, equalityExpr };
equalityExpr
    = relationalExpr, { equalityOp, relationalExpr };
relationalExpr 
    = additiveExpr, { relationalOp, additiveExpr };
additiveExpr 
    = multiplicativeExpr, { additiveOp, multiplicativeExpr };
multiplicativeExpr 
    = unaryOpExpr, { multiplicativeOp, unaryOpExpr };
unaryOpExpr
    = [ unaryOp ], functionalExpr;
functionalExpr
    = primaryExpr, { functionalOpExpr };

primaryExpr
    = identifier
    | literal
    | parenExpr
    | castExpr;

parenExpr 
    = "(", expression, ")";
castExpr
    = primitiveType, "(", expression, ")";

                                                    
(* OPERATORS *)             (* RETURNED BY LEXER *) 

logicOrOp                   (* prio 0 l-r *)
    = "||";

logicAndOp                  (* prio 1 l-r *)
    = "&&";

equalityOp                  (* prio 2 l-r *)
    = "==" 
    | "!=";

relationalOp                (* prio 3 l-r *)
    = "<" 
    | ">" 
    | "<=" 
    | ">=";

additiveOp                  (* prio 4 l-r *)
    = "+" 
    | "-";

multiplicativeOp            (* prio 5 l-r *)
    = "*" 
    | "/" 
    | "%";

unaryOp                     (* prio 6 r-l *)
    = "!"
    | "-";

functionalOpExpr            (* prio 7 l-r *)
    = fnCallOp 
    | memberAccessOp 
    | variantAccessOp;

fnCallOp
    = "(", [ expression, { ",", expression } ], ")"; 
memberAccessOp 
    = ".", identifier;
variantAccessOp
    = "as", typeIdentifier;


(* DEFINITIONS *)

Definition
    = VarDef
    | ConstDef
    | StructDef
    | VariantDef
    | FnDef;

VarDef
    = "var", identifier, ":", typeIdentifier, "=", expression, ";";
ConstDef
    = "const", identifier, ":", typeIdentifier, "=", expression, ";";

StructDef
    = "struct", identifier, "{", [ structMembers ], "}", ";";
structMembers
    = structMember, { structMember };
structMember
    = identifier, ":", typeIdentifier, ";";

VariantDef
    = "variant", identifier, "{", [ variantTypes ], "}", ";";
variantTypes
    = variantType, { ",", variantType };
variantType
    = typeIdentifier

FnDef
    = "fn", identifier, "(", [ fnParams ], ")", returnTypeAnnotation, Block;
fnParams
    = fnParam, { ",", fnParam };
fnParam
    = [ "const" ], identifier, ":", typeIdentifier;
fnReturnType
    = "->", typeIdentifier;


(* STATEMENTS *)

Statement
    = VarDef
    | ConstDef
    | ExpressionOrAssignmentStatement
    | StdinExtraction
    | StdoutInsertion
    | VariantMatchStatement
    | IfStatement
    | ForStatement
    | WhileStatement
    | ContinueStatement
    | BreakStatement
    | ReturnStatement
    | Block;

StdinExtraction
    = ">>", expression, ";";
StdoutInsertion
    = "<<", expression, { "<<", expression }, ";";

ExpressionOrAssignmentStatement
    = expression, [ "=", expression ], ";";

VariantMatchStatement
    = "match", expression, "{", { variantCase }, "}";
variantCase
    = "case", typeIdentifier, "->", Block;

IfStatement
    = "if", { elifClause }, [ elseClause ];
elifClause
    = "elif", expression, Block;
elseClause
    = "else", Block;

WhileStatement
    = "while", expression, Block;

ForStatement
    = "for", identifier, "in", range, Block;
range
    = expression, "until", expression;

ReturnStatement
    = "return", [ expression ], ";";

BreakStatement
    = "break", ";";
ContinueStatement
    = "continue", ";";

Block
    = "{", { Statement }, "}";
