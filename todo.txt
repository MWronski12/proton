1) Fixes

    - extract common part form vardef, constdef or generalize into
      [ varSpecifier ], id, ":", type, [ "=", expression ], ";"
    - stof
    - comments from lexer
    - parseElifs
    - It should be clear in Parser code that ErrorHandler::operator() exits if ErrorLevel::Error, 
      (remove return nullptr, rename consumeIf -> expect)
    - More Expression tests
    - Parser maps to anonymous space
    - Grammar-comments integrity
    - dont use exception for controlflow in parseLiteral

2) ScopeAnalyzer

    - Enter scope on block and for enter
    - Exit scope on block or for return

    - Add <typeId, _> entry on definition 
    - Assert exists in table whenever non declaration identifier 

3) TypeChecker (needs additional stack for results from node visitation)

    - Enter scope on block and for enter
    - Exit scope on block or for return

    - Add <typeId, returnedTypeId from<fnReturnType, struct/variant typeId, literal>>
    - case
      - var/const/struct def -> assert type from expression matches typeIdentifier
      - fnDef -> assert return type matches return expression type
      - 

3) Interpreter

obj pool - how to use objects created by prev visitors
All by value, but anticipate references
    - How to manage scope? env, stack of fncallcontesxts, last retval, last compresult
    - How to handle continue, break, return
    - How to store all existing symbols (name, val)
    - How to handle shadowing?
    - How to exaluate complex expressions?
