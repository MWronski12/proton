# ------------------------------- START SYMBOL ------------------------------- #
program = {fnDecl}, main;
main = "fn", "main", "(", ")", "->", "int", block;

# ---------------------------- LEXICAL CONVENTIONS --------------------------- #
nonZeroDigit = "1" |  "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9";
digit = "0" | nonZeroDigit;
letter = "a" | "b" | ... | "z" | "A" | "B" | ... | "Z";
character = any character;
positiveInteger = nonZeroDigit, {digit};
comment = "$", single line comment;
        | "$$", multi line comment, "$$";
identifier = letter, {letter | digit};


# --------------------------------- LITERALS --------------------------------- #

integer = [sign], "0" | nonZeroDigit, {digit};
float = [sign], integer, ".", digit+;
string = '"', {character}, '"';
literal = integer | float | string | "true" | "false" | "null" | object;
object = "{" , literal, {literal, ","}, "}";


# ----------------------------------- TYPES ---------------------------------- #

type = primitiveType
     | arrayType
     | variantType
     | typeIdentifier;

typeWithVoid = type | "void";

primitiveType = "int" | "float" | "byte" | "bool" | "string";
arrayType = primitiveType, "[", "]";
variantType = "variant", "<", type, {",", type}, ">";
typeIdentifier = identifier;


# ------------------------------- Declarations ------------------------------- #

varDecl = identifier, ":", type;
constDecl = "const", identifier, ":", type, "=", expression;
fnDecl = "fn", identifier, "(", [varDecl | constDecl, {",", varDecl | constDecl}], ")", "->", type, block;
typeDecl = "type", identifier, "{", {varDecl, ";"}, "}", block;
block = "{", {statement}, "}";


# -------------------------------- STATEMENTS -------------------------------- #

statement = (varDecl
          | constDecl
          | typeDecl
          | fnDecl
          | assignment
          | ifStatement
          | forStatement
          | whileStatement
          | returnStatement), ";";

assignment = (identifier
           | varAccess
           | varDecl), "=", expression;

varAccess = | memberAccess;
            | variantAccess;

memberAccess = expression, {".", identifier};
variantAccess = expression, "as", type;
variantCheck = expression, "holds", type;

ifStatement = "if", "(", expression, ")" block, {elif, "(", expression, ")", block}, ["else", block];
forStatement = "for", range, block;
whileStatement = "iter", "while", "(", expression, ")", block;
returnStatement = "return", [expression];

range = "iter", identifier, [expression], "..", expression, block;


# -------------------------------- EXPRESSIONS ------------------------------- #

expression = simpleExpression, [relOp, simpleExpression];
simpleExpression = [sign], term, {addOp, term};
parenExpression = "(", expression, ")";
term = factor, {mulOp, factor};
factor = varIdentifier
       | literal
       | parenExpression
       | variantCheck
       | fnCall
       | (negation, parenExpression);

relOp = "=" | "!=" | "<" | ">" | "<=" | ">=";
sign = "+" | "-";
addOp = "+" | "-" | "||";
mulOp = "*" | "/" | "%" | "&&" | "^" | "|" | "&";
negation = "!" | "~";

varIdentifier = identifier | varAccess;
fnCall = identifier, "(", [expression, {",", expression}], ")";
